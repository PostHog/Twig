import { existsSync, mkdirSync, writeFileSync } from "node:fs";
import { dirname, join } from "node:path";
import { createError, err, ok, type Result } from "./result";

const STACK_CHECK_WORKFLOW = `# Generated by Array CLI - https://github.com/posthog/array
# Blocks stacked PRs until their downstack dependencies are merged
# Only runs for PRs managed by Array (detected via stack comment marker)

name: Stack Check

on:
  pull_request:
    types: [opened, synchronize, reopened, edited]
  pull_request_target:
    types: [closed]

permissions:
  contents: read

jobs:
  check:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    permissions:
      pull-requests: read
      issues: read
    steps:
      - name: Check stack dependencies
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;

            // Check if this is an Array-managed PR by looking for stack comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number
            });

            const isArrayPR = comments.some(c =>
              c.body.includes('<!-- array-stack-comment -->')
            );

            if (!isArrayPR) {
              console.log('Not an Array PR, skipping');
              return;
            }

            const baseBranch = pr.base.ref;
            const trunk = ['main', 'master', 'develop'];

            if (trunk.includes(baseBranch)) {
              console.log('Base is trunk, no dependencies');
              return;
            }

            async function getBlockers(base, visited = new Set()) {
              if (trunk.includes(base) || visited.has(base)) {
                return [];
              }
              visited.add(base);

              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                head: \`\${context.repo.owner}:\${base}\`
              });

              if (prs.length === 0) {
                return [];
              }

              const blocker = prs[0];
              const upstream = await getBlockers(blocker.base.ref, visited);
              return [{ number: blocker.number, title: blocker.title }, ...upstream];
            }

            const blockers = await getBlockers(baseBranch);

            if (blockers.length > 0) {
              const list = blockers.map(b => \`#\${b.number} (\${b.title})\`).join('\\n  - ');
              core.setFailed(\`Blocked by:\\n  - \${list}\\n\\nMerge these PRs first (bottom to top).\`);
            } else {
              console.log('All dependencies merged, ready to merge');
            }

  recheck-dependents:
    runs-on: ubuntu-latest
    if: >-
      github.event_name == 'pull_request_target' &&
      github.event.action == 'closed' &&
      github.event.pull_request.merged == true
    permissions:
      pull-requests: write
      issues: read
    steps:
      - name: Trigger recheck of dependent PRs
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;

            // Check if this is an Array-managed PR
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number
            });

            const isArrayPR = comments.some(c =>
              c.body.includes('<!-- array-stack-comment -->')
            );

            if (!isArrayPR) {
              console.log('Not an Array PR, skipping');
              return;
            }

            const mergedBranch = pr.head.ref;

            const { data: dependentPRs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: mergedBranch,
              state: 'open'
            });

            for (const dependentPR of dependentPRs) {
              console.log(\`Retargeting PR #\${dependentPR.number} to \${pr.base.ref}\`);
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: dependentPR.number,
                base: pr.base.ref
              });
            }
`;

export interface SetupCIResult {
  created: boolean;
  updated: boolean;
  path: string;
}

function getWorkflowPath(cwd: string): string {
  return join(cwd, ".github", "workflows", "array-stack-check.yml");
}

export function setupCI(cwd: string): SetupCIResult {
  const workflowPath = getWorkflowPath(cwd);
  const existed = existsSync(workflowPath);

  const workflowDir = dirname(workflowPath);
  mkdirSync(workflowDir, { recursive: true });
  writeFileSync(workflowPath, STACK_CHECK_WORKFLOW);

  return {
    created: !existed,
    updated: existed,
    path: workflowPath,
  };
}

export interface EnableProtectionResult {
  success: boolean;
  error?: string;
  alreadyEnabled?: boolean;
  updated?: boolean;
}

export function getRepoInfoFromRemote(
  remoteUrl: string,
): Result<{ owner: string; repo: string }> {
  // Handle SSH format: git@github.com:owner/repo.git
  // Use [\w-]+ to match valid GitHub usernames/org names (alphanumeric, underscore, hyphen)
  const sshMatch = remoteUrl.match(
    /^git@github\.com:([\w-]+)\/([\w.-]+?)(?:\.git)?$/,
  );
  if (sshMatch) {
    return ok({ owner: sshMatch[1], repo: sshMatch[2] });
  }

  // Handle HTTPS format: https://github.com/owner/repo.git
  const httpsMatch = remoteUrl.match(
    /^https:\/\/github\.com\/([\w-]+)\/([\w.-]+?)(?:\.git)?$/,
  );
  if (httpsMatch) {
    return ok({ owner: httpsMatch[1], repo: httpsMatch[2] });
  }

  return err(
    createError("COMMAND_FAILED", "Could not parse GitHub remote URL"),
  );
}

export function getBranchProtectionUrl(owner: string, repo: string): string {
  // Use the newer rulesets UI with as many prefilled params as possible
  const params = new URLSearchParams({
    target: "branch",
    enforcement: "active",
    name: "Array Stack Check",
    // Try common param patterns for the check name
    required_status_checks: "Stack Check",
  });
  return `https://github.com/${owner}/${repo}/settings/rules/new?${params.toString()}`;
}

export interface EnableProtectionOptions {
  owner: string;
  repo: string;
  trunk: string;
}

export async function checkRulesetExists(
  owner: string,
  repo: string,
  executor: {
    execute: (
      cmd: string,
      args: string[],
      opts: { cwd: string },
    ) => Promise<{ exitCode: number; stdout: string; stderr: string }>;
  },
  cwd: string,
): Promise<boolean> {
  const listResult = await executor.execute(
    "gh",
    [
      "api",
      `-H`,
      `Accept: application/vnd.github+json`,
      `/repos/${owner}/${repo}/rulesets`,
    ],
    { cwd },
  );

  if (listResult.exitCode === 0) {
    try {
      const rulesets = JSON.parse(listResult.stdout);
      return rulesets.some(
        (r: { name: string }) => r.name === "Array Stack Check",
      );
    } catch {
      return false;
    }
  }
  return false;
}

export async function enableStackCheckProtection(
  options: EnableProtectionOptions,
  executor: {
    execute: (
      cmd: string,
      args: string[],
      opts: { cwd: string },
    ) => Promise<{ exitCode: number; stdout: string; stderr: string }>;
  },
  cwd: string,
): Promise<EnableProtectionResult> {
  const { owner, repo } = options;

  // Ruleset configuration
  const rulesetBody = {
    name: "Array Stack Check",
    target: "branch",
    enforcement: "active",
    conditions: {
      ref_name: {
        include: ["~DEFAULT_BRANCH"],
        exclude: [],
      },
    },
    rules: [
      {
        type: "required_status_checks",
        parameters: {
          required_status_checks: [
            {
              context: "Stack Check",
              integration_id: 15368, // GitHub Actions
            },
          ],
          strict_required_status_checks_policy: false,
        },
      },
    ],
  };

  // Check if ruleset already exists
  const listResult = await executor.execute(
    "gh",
    [
      "api",
      `-H`,
      `Accept: application/vnd.github+json`,
      `/repos/${owner}/${repo}/rulesets`,
    ],
    { cwd },
  );

  let existingId: number | null = null;
  if (listResult.exitCode === 0) {
    try {
      const rulesets = JSON.parse(listResult.stdout);
      const existing = rulesets.find(
        (r: { name: string; id: number }) => r.name === "Array Stack Check",
      );
      if (existing) {
        existingId = existing.id;
      }
    } catch {
      // Continue to create
    }
  }

  const body = JSON.stringify(rulesetBody);

  // Update existing or create new
  if (existingId) {
    const updateResult = await executor.execute(
      "bash",
      [
        "-c",
        `echo '${body}' | gh api --method PUT -H "Accept: application/vnd.github+json" /repos/${owner}/${repo}/rulesets/${existingId} --input -`,
      ],
      { cwd },
    );

    if (updateResult.exitCode === 0) {
      return { success: true, updated: true };
    }

    const stderr = updateResult.stderr.toLowerCase();
    if (
      stderr.includes("403") ||
      stderr.includes("404") ||
      stderr.includes("must have admin")
    ) {
      return {
        success: false,
        error: "Admin access required. Ask a repo admin to run this command.",
      };
    }
    return {
      success: false,
      error: updateResult.stderr || "Failed to update ruleset",
    };
  }

  const createResult = await executor.execute(
    "bash",
    [
      "-c",
      `echo '${body}' | gh api --method POST -H "Accept: application/vnd.github+json" /repos/${owner}/${repo}/rulesets --input -`,
    ],
    { cwd },
  );

  if (createResult.exitCode === 0) {
    return { success: true };
  }

  const stderr = createResult.stderr.toLowerCase();
  if (
    stderr.includes("403") ||
    stderr.includes("404") ||
    stderr.includes("must have admin")
  ) {
    return {
      success: false,
      error: "Admin access required. Ask a repo admin to run this command.",
    };
  }

  return {
    success: false,
    error: createResult.stderr || "Failed to create ruleset",
  };
}
